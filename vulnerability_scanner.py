import requests
from bs4 import BeautifulSoup
import re
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor
import colorama
from colorama import Fore, Style
import ssl
import socket
from datetime import datetime

colorama.init(autoreset=True)

class VulnerabilityScanner:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'})
        self.vulnerabilities = []

    def scan(self):
        print(f"{Fore.YELLOW}Starting vulnerability scan for {self.target_url}{Style.RESET_ALL}")
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            executor.submit(self.check_sql_injection)
            executor.submit(self.check_xss)
            executor.submit(self.check_open_redirects)
            executor.submit(self.check_directory_listing)
            executor.submit(self.check_ssl_tls)

        return self.vulnerabilities

    def check_sql_injection(self):
        payloads = ["'", "\"", "1' OR '1'='1", "1\" OR \"1\"=\"1"]
        vulnerable_params = []

        try:
            response = self.session.get(self.target_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')

            for form in forms:
                action = urljoin(self.target_url, form.get('action', ''))
                method = form.get('method', 'get').lower()
                inputs = form.find_all('input')
                
                for input_field in inputs:
                    input_name = input_field.get('name')
                    if input_name:
                        for payload in payloads:
                            data = {input_name: payload}
                            if method == 'post':
                                r = self.session.post(action, data=data)
                            else:
                                r = self.session.get(action, params=data)
                            
                            if 'SQL syntax' in r.text or 'mysql_fetch_array()' in r.text:
                                vulnerable_params.append(input_name)
                                break

            if vulnerable_params:
                self.vulnerabilities.append(f"Potential SQL Injection in parameters: {', '.join(vulnerable_params)}")
            else:
                print(f"{Fore.GREEN}No SQL Injection vulnerabilities detected.{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Error during SQL Injection check: {str(e)}{Style.RESET_ALL}")

    def check_xss(self):
        payloads = ['<script>alert("XSS")</script>', '"><script>alert("XSS")</script>', '"><img src=x onerror=alert("XSS")>']
        vulnerable_params = []

        try:
            response = self.session.get(self.target_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')

            for form in forms:
                action = urljoin(self.target_url, form.get('action', ''))
                method = form.get('method', 'get').lower()
                inputs = form.find_all('input')
                
                for input_field in inputs:
                    input_name = input_field.get('name')
                    if input_name:
                        for payload in payloads:
                            data = {input_name: payload}
                            if method == 'post':
                                r = self.session.post(action, data=data)
                            else:
                                r = self.session.get(action, params=data)
                            
                            if payload in r.text:
                                vulnerable_params.append(input_name)
                                break

            if vulnerable_params:
                self.vulnerabilities.append(f"Potential XSS in parameters: {', '.join(vulnerable_params)}")
            else:
                print(f"{Fore.GREEN}No XSS vulnerabilities detected.{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Error during XSS check: {str(e)}{Style.RESET_ALL}")

    def check_open_redirects(self):
        payloads = ['//google.com', '//example.com', '////google.com', '////example.com']
        vulnerable_params = []

        try:
            response = self.session.get(self.target_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            links = soup.find_all('a', href=True)

            for link in links:
                url = urljoin(self.target_url, link['href'])
                parsed = urlparse(url)
                if any(param.startswith(('url', 'redirect', 'next', 'redir', 'to', 'link')) for param in parsed.query.split('&')):
                    for payload in payloads:
                        test_url = url.replace(parsed.query, f'{parsed.query}&url={payload}')
                        r = self.session.get(test_url, allow_redirects=False)
                        if r.status_code in (301, 302) and payload in r.headers.get('Location', ''):
                            vulnerable_params.append(url)
                            break

            if vulnerable_params:
                self.vulnerabilities.append(f"Potential Open Redirects in URLs: {', '.join(vulnerable_params)}")
            else:
                print(f"{Fore.GREEN}No Open Redirect vulnerabilities detected.{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Error during Open Redirect check: {str(e)}{Style.RESET_ALL}")

    def check_directory_listing(self):
        try:
            common_dirs = ['/images', '/uploads', '/admin', '/css', '/js', '/backup']
            for dir in common_dirs:
                url = urljoin(self.target_url, dir)
                response = self.session.get(url)
                if 'Index of' in response.text:
                    self.vulnerabilities.append(f"Directory Listing enabled at: {url}")

            if not any('Directory Listing' in vuln for vuln in self.vulnerabilities):
                print(f"{Fore.GREEN}No Directory Listing vulnerabilities detected.{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Error during Directory Listing check: {str(e)}{Style.RESET_ALL}")

    def check_ssl_tls(self):
        try:
            parsed_url = urlparse(self.target_url)
            hostname = parsed_url.hostname
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as secure_sock:
                    cert = secure_sock.getpeercert()
            
            ssl_version = secure_sock.version()
            if ssl_version in ['TLSv1', 'TLSv1.1']:
                self.vulnerabilities.append(f"Weak SSL/TLS version in use: {ssl_version}")
            else:
                print(f"{Fore.GREEN}SSL/TLS version is up to date: {ssl_version}{Style.RESET_ALL}")

            expiration_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
            if expiration_date < datetime.now():
                self.vulnerabilities.append(f"SSL certificate has expired on {expiration_date}")
            else:
                print(f"{Fore.GREEN}SSL certificate is valid until {expiration_date}{Style.RESET_ALL}")

        except Exception as e:
            print(f"{Fore.RED}Error during SSL/TLS check: {str(e)}{Style.RESET_ALL}")

def vulnerability_scanner(target_url):
    scanner = VulnerabilityScanner(target_url)
    vulnerabilities = scanner.scan()
    
    if vulnerabilities:
        print(f"\n{Fore.RED}Vulnerabilities Detected:{Style.RESET_ALL}")
        for vuln in vulnerabilities:
            print(f"- {vuln}")
    else:
        print(f"\n{Fore.GREEN}No vulnerabilities detected.{Style.RESET_ALL}")

    return vulnerabilities

if __name__ == "__main__":
    target_url = input(f"{Fore.YELLOW}Enter the target URL: {Style.RESET_ALL}")
    vulnerability_scanner(target_url)
